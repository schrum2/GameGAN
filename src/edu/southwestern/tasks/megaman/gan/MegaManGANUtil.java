package edu.southwestern.tasks.megaman.gan;

import java.awt.Point;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import edu.southwestern.parameters.Parameters;
import edu.southwestern.tasks.mario.gan.GANProcess;
import edu.southwestern.tasks.mario.gan.reader.JsonReader;
import edu.southwestern.tasks.megaman.MegaManTrackSegmentType;
import edu.southwestern.tasks.megaman.MegaManVGLCUtil;
import edu.southwestern.tasks.megaman.astar.MegaManState;
import edu.southwestern.tasks.megaman.levelgenerators.MegaManGANGenerator;
import edu.southwestern.util.datastructures.Pair;

public class MegaManGANUtil {
	public static final int MEGA_MAN_ALL_TERRAIN = 7; //number of tiles in MegaMan
	public static final int MEGA_MAN_TILES_WITH_ENEMIES = 30; //number of tiles in MegaMan
	public static final int MEGA_MAN_FIRST_LEVEL_ALL_TILES = 21; //number of tiles in MegaMan
	public static final int MEGA_MAN_ONE_ENEMY = 12; //number of tiles in MegaMan

	public static final int MEGA_MAN_LEVEL_WIDTH = 16;
	public static final int MEGA_MAN_LEVEL_HEIGHT = 14;
	public static int numUp;
	public static int numDown;
	public static int numRight;
	public static int numLeft;

	public static int numCorner;
	public static int numDistinctSegments;

	/**
	 * Renders a level that was generated by the GAN 
	 * @param args
	 * @throws IOException 
	 */
//	public static void main(String[] args) throws IOException {
//		final int LATENT_VECTOR_SIZE = 5; // Just for this test
//		GANProcess.type = GANProcess.GAN_TYPE.MEGA_MAN; //sets GAN type to LodeRunner
//		Parameters.initializeParameterCollections(new String[] {"GANInputSize:"+LATENT_VECTOR_SIZE});//input size is the size of the latent vector
//		double[] latentVector = RandomNumbers.randomArray(LATENT_VECTOR_SIZE); //fills array of input size randomly
//		List<List<Integer>> oneLevel = generateOneLevelListRepresentationFromGANHorizontal(latentVector); //one level to render
//		BufferedImage[] images = MegaManRenderUtil.loadImagesForASTAR(MegaManRenderUtil.MEGA_MAN_TILE_PATH); //Initializes the array that hold the tile images
//		MegaManRenderUtil.getBufferedImage(oneLevel,images);//rendered level and displays it in a window 
//		GANProcess.terminateGANProcess(); //ends GAN process 
//	}
	
	public static GANProcess initializeGAN(String modelType) {
		GANProcess newGAN = new GANProcess(GANProcess.PYTHON_BASE_PATH+"MegaManGAN"+ File.separator + Parameters.parameters.stringParameter(modelType), 
				Parameters.parameters.integerParameter("GANInputSize"), 
				Parameters.parameters.stringParameter(modelType).contains("With7Tile") ? MegaManGANUtil.MEGA_MAN_ALL_TERRAIN : MegaManGANUtil.MEGA_MAN_ONE_ENEMY,
				GANProcess.MEGA_MAN_OUT_WIDTH, GANProcess.MEGA_MAN_OUT_HEIGHT);
		return newGAN;
	}
	public static void postProcessingPlaceProperEnemies(List<List<Integer>> level) {
		for(int y=0;y<level.size();y++) {
			for(int x=0;x<level.get(0).size();x++) {
				if(level.get(y).get(x)==MegaManVGLCUtil.ONE_ENEMY_GROUND_ENEMY) {
					if((x>0&&level.get(y).get(x-1)==MegaManVGLCUtil.ONE_ENEMY_SOLID)||(x+1<level.get(0).size()&&level.get(y).get(x+1)==MegaManVGLCUtil.ONE_ENEMY_SOLID)) {
						level.get(y).set(x, MegaManVGLCUtil.ONE_ENEMY_WALL_ENEMY);
					}else if((y>0&&level.get(y-1).get(x)==MegaManVGLCUtil.ONE_ENEMY_SOLID)||(y+1<level.size()&&level.get(y+1).get(x)==MegaManVGLCUtil.ONE_ENEMY_SOLID)) {
						level.get(y).set(x, MegaManVGLCUtil.ONE_ENEMY_GROUND_ENEMY);
					}else {
						level.get(y).set(x, MegaManVGLCUtil.ONE_ENEMY_FLYING_ENEMY);
					}
					}
			}
		}
	}
	public static void startGAN(GANProcess gan) {
		gan.start();
		String response = "";
		while(!response.equals("READY")) {

			response = gan.commRecv();
		}
	}
	/**
	 * Gets a set of all of the levels from the latent vector 
	 * @param gan Specific GAN model to use as a generator
	 * @param latentVector
	 * @return Set of all the levels
	 */
	public static List<List<List<Integer>>> getLevelListRepresentationFromGAN(GANProcess gan, double[] latentVector){
		
		latentVector = GANProcess.mapArrayToOne(latentVector); // Range restrict the values
		int chunk_length = Integer.valueOf(gan.GANDim);
		String levelString = "";
		for(int i = 0; i < latentVector.length; i+=chunk_length){
			double[] chunk = Arrays.copyOfRange(latentVector, i, i+chunk_length);
			// Generate a level from the vector
			// Brackets required since generator.py expects of list of multiple levels, though only one is being sent here
			try {
				gan.commSend("[" + Arrays.toString(chunk) + "]");
			} catch (IOException e) {
				e.printStackTrace();
				System.exit(1); // Cannot continue without the GAN process
			}
			String oneLevelChunk = gan.commRecv(); // Response to command just sent
			levelString = levelString + ", " + oneLevelChunk;  
		}
		// These two lines remove the , from the first append to an empty string
		levelString = levelString.replaceFirst(",", "");
		levelString = levelString.replaceFirst(" ", "");
		levelString = "["+levelString+"]"; // Make a bundle of several levels
		// Create one level from all
		List<List<List<Integer>>> allLevels = JsonReader.JsonToInt(levelString);
		// This list contains several separate levels. The following code
		// merges the levels by appending adjacent rows
		List<List<Integer>> oneLevel = new ArrayList<List<Integer>>();
		// Create the appropriate number of rows in the array
		for(@SuppressWarnings("unused") List<Integer> row : allLevels.get(0)) { // Look at first level (assume all are same size)
			oneLevel.add(new ArrayList<Integer>()); // Empty row
		}
		// Now fill up the rows, one level at a time
		for(List<List<Integer>> aLevel : allLevels) {
			int index = 0;
			for(List<Integer> row : aLevel) { // Loot at each row
				oneLevel.get(index++).addAll(row);
			}	
		}
		return allLevels;
	}

	/**
	 * Gets one level from the list of levels, chooses the first one in the list  
	 * @param latentVector
	 * @return A single level 
	 */
	public static List<List<Integer>> generateOneLevelListRepresentationFromGANHorizontal(double[] latentVector) {
		// Since only one model is needed, using the standard getGANProcess
		List<List<List<Integer>>> levelInList = getLevelListRepresentationFromGAN(GANProcess.getGANProcess(), latentVector);
		List<List<Integer>> oneLevel = levelInList.get(0); // gets first level in the set 
		//List<List<Integer>> fullLevel = new ArrayList<List<Integer>>();
		for(int level = 1;level<levelInList.size();level++) {
			for(int i = 0;i<oneLevel.size();i++) {
				//for(int integer = 0; integer<oneLevel.get(0).size();integer++) {
				oneLevel.get(i).addAll(levelInList.get(level).get(i));

				
			}
		}
		
		
		return oneLevel;
	}
	
	/**
	 * Generates level segments from GAN, but stitches them together vertically rather than horizontally
	 * @param latentVector
	 * @return
	 */
	public static List<List<Integer>> generateOneLevelListRepresentationFromGANVertical(double[] latentVector) {
		// Since only one model is needed, using the standard getGANProcess
		List<List<List<Integer>>> levelInList = getLevelListRepresentationFromGAN(GANProcess.getGANProcess(), latentVector);
		List<List<Integer>> oneLevel = levelInList.get(0); // gets first level in the set 
		//List<List<Integer>> fullLevel = new ArrayList<List<Integer>>();
		for(int level = 1;level<levelInList.size();level++) {
			//for(int i = 0;i<oneLevel.size();i++) {
				//for(int integer = 0; integer<oneLevel.get(0).size();integer++) {
				oneLevel.addAll(levelInList.get(level));

				
			//}
		}
		
		
		return oneLevel;
	}
//	public enum Direction {UP, RIGHT, DOWN};

//	public static int 
//	public static List<List<Integer>> generateOneLevelListRepresentationFromGANVerticalAndHorizontal(GANProcess horizontalGAN, GANProcess upGAN, GANProcess downGAN, GANProcess lowerLeftGAN, GANProcess lowerRightGAN,  GANProcess upperLeftGAN, GANProcess upperRightGAN, double[] latentVector) {
//		// Just grabbing the static GANProcess for now, but you will need to make this method accept two separate GAN models eventually.
//		 numHorizontal = 0;
//		 numUp = 0;
//		 numDown = 0;
//		 numCorner = 0;
//		 numDistinctSegments = 0;
//		Random rand = new Random(Double.doubleToLongBits(latentVector[0]));
//		List<List<List<Integer>>> levelInListHorizontal;
//		List<List<List<Integer>>> levelInListUp;
//		List<List<List<Integer>>> levelInListDown;
//		List<List<List<Integer>>> levelInListUpperRight = getLevelListRepresentationFromGAN(upperRightGAN, latentVector);
//		List<List<List<Integer>>> levelInListUpperLeft= getLevelListRepresentationFromGAN(upperLeftGAN, latentVector);
//		List<List<List<Integer>>> levelInListLowerRight = getLevelListRepresentationFromGAN(lowerRightGAN, latentVector);
//		List<List<List<Integer>>> levelInListLowerLeft = getLevelListRepresentationFromGAN(lowerLeftGAN, latentVector);
//
//
//
//
//		HashSet<List<List<Integer>>> distinct = new HashSet<>();
//		boolean startRight = rand.nextBoolean();
//		//if(startRight) {
////		System.out.println(horizontalGAN);
////		MiscUtil.waitForReadStringAndEnterKeyPress();
//			levelInListHorizontal = getLevelListRepresentationFromGAN(horizontalGAN, latentVector);
//	//	}else {
//			levelInListUp = getLevelListRepresentationFromGAN(upGAN, latentVector);
//			levelInListDown = getLevelListRepresentationFromGAN(downGAN, latentVector);
//
//		//}
//			//boolean startUp = rand.nextBoolean();
//
//			Direction d;
//	//	if(startRight)
//		
////		else if(startUp) {
////			d = Direction.UP;
////		}else {
////			d = Direction.DOWN;
//		//}
//		//List<Point> allPreviousMoves = new ArrayList<Point>();
//		Point previousMove = new Point(0,0);
//		int numberOfChunks = levelInListHorizontal.size();
//		boolean right;
//		boolean up;
////		boolean wasRight = true;
////		boolean wasUp = false;
//		List<List<Integer>> oneLevel;
//		
//		if(startRight) {
//			oneLevel= levelInListHorizontal.get(0); // gets first level in the set 
//			numHorizontal++;
//			d = Direction.RIGHT;
//		}
//		else {
//			oneLevel = levelInListUp.get(0);
//			numUp++;
//			d = Direction.UP;
//		}
//		distinct.add(oneLevel);
//		List<Integer> nullLine = new ArrayList<Integer>(16);
//		placeSpawn(oneLevel);
//		if(numberOfChunks==1) {
//			placeOrb(oneLevel);
//		}
//		for(int i=0;i<MEGA_MAN_LEVEL_WIDTH;i++) {
//			nullLine.add(MegaManState.MEGA_MAN_TILE_NULL);
//		}
//		int itr = 1;
//		for(int level = 1;level<numberOfChunks;level++) {
//			right = rand.nextBoolean();
////				if(level==numberOfChunks-1&&right) {
////					placeOrb(levelInListHorizontal.get(0));
////				}else if(level==numberOfChunks-1&&!right) {
////					placeOrb(levelInListUp.get(0));
////					placeOrb(levelInListDown.get(0));
////				}
//				Direction previous = d;
//			if(right) {
//				if(previous.equals(Direction.UP)) {
//					if(level==numberOfChunks-1) placeOrb(levelInListUpperLeft.get(itr));
//					placeUp(levelInListUpperLeft, previousMove, oneLevel, itr);
//					level++;
//					
//
//				}else if(previous.equals(Direction.DOWN)) {
//					if(level==numberOfChunks-1) placeOrb(levelInListLowerLeft.get(itr));
//					placeDown(levelInListLowerLeft, previousMove, oneLevel, itr);
//					level++;
//					previousMove=new Point((int) previousMove.getX(),(int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT);
//
//				}
//				numHorizontal++;
//				if(level==numberOfChunks-1) placeOrb(levelInListHorizontal.get(itr));
//				placeRight(levelInListHorizontal, previousMove, oneLevel, nullLine, itr);
//				distinct.add(levelInListHorizontal.get(1));
//
//				//wasRight = true;
//				d = Direction.RIGHT;
//				previousMove=new Point((int) previousMove.getX()+MEGA_MAN_LEVEL_WIDTH,(int) previousMove.getY());
//
//			}else {
//				up = rand.nextBoolean();
//				
//				if(d.equals(Direction.UP)) {
//					d = Direction.UP;
//				}else if(d.equals(Direction.DOWN)) { //can't add up then down then up
//					d = Direction.DOWN;
//				}else {
//					if(up) {
//						d = Direction.UP;
//					}else {
//						d = Direction.DOWN;
//					}
//				}
//				if(d.equals(Direction.UP)) { //add null lines all on top
//					if(previous.equals(Direction.RIGHT)) {
//						if(level==numberOfChunks-1) placeOrb(levelInListLowerRight.get(itr));
//						placeRight(levelInListLowerRight, previousMove, oneLevel, nullLine, itr);
//						level++;
//						previousMove=new Point((int) previousMove.getX()+MEGA_MAN_LEVEL_WIDTH,(int) previousMove.getY());
//
//					}
//					numUp++;
//					if(level==numberOfChunks-1) placeOrb(levelInListUp.get(itr));
//					placeUp(levelInListUp, previousMove, oneLevel, itr);
//					distinct.add(levelInListUp.get(itr));
//					
//
//					
//				}else {
//					if(previous.equals(Direction.RIGHT)) {
//						if(level==numberOfChunks-1) placeOrb(levelInListUpperRight.get(itr));
//						placeRight(levelInListUpperRight, previousMove, oneLevel, nullLine, itr);
//						level++;
//						previousMove=new Point((int) previousMove.getX()+MEGA_MAN_LEVEL_WIDTH,(int) previousMove.getY());
//
//					}
//					numDown++;
//					if(level==numberOfChunks-1) placeOrb(levelInListDown.get(itr));
//					placeDown(levelInListDown, previousMove, oneLevel, itr);
//					distinct.add(levelInListDown.get(itr));
//					previousMove=new Point((int) previousMove.getX(),(int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT);
//					
//					
//
//					
//					
//				}
//				//wasRight=false;
//			}
//			if(!d.equals(previous)) {
//				numCorner++;
//			}
//			previous = d;
//			numDistinctSegments = distinct.size();
//			itr++;
//		}
//		
//		if(!Parameters.parameters.booleanParameter("megaManUsesUniqueEnemies")) {
//			MegaManGANUtil.postProcessingPlaceProperEnemies(oneLevel);
//		}
//		return oneLevel;
//	}
//
//	public static void placeDown(List<List<List<Integer>>> levelInListDown, Point previousMove,
//			List<List<Integer>> oneLevel, int level) {
//		int y1 = (int) previousMove.getY();
//		if(y1+15>=oneLevel.size()) {
//			List<List<Integer>> nullScreen = new ArrayList<List<Integer>>();
//			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
//				List<Integer> nullLines = new ArrayList<Integer>();
//				for(int j = 0;j<oneLevel.get(0).size();j++) {
//					nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
//				}
//				nullScreen.add(nullLines);
//			}
//			oneLevel.addAll(oneLevel.size(), nullScreen);
//		}
//		
//		
//		for(int y = (int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y<previousMove.getY()+2*MEGA_MAN_LEVEL_HEIGHT;y++) {
//			for(int x = (int) previousMove.getX();x<previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x++) {
//				oneLevel.get(y).set(x, levelInListDown.get(level).get((int) (y -MEGA_MAN_LEVEL_HEIGHT- previousMove.getY())).get((int) (x-previousMove.getX())));
//			}
//		}
//	}
//
//	public static void placeUp(List<List<List<Integer>>> levelInListUp, Point previousMove,
//			List<List<Integer>> oneLevel, int level) {
//		if((int) previousMove.getY()==0) {
//		List<List<Integer>> nullScreen = new ArrayList<List<Integer>>();
//		for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
//			List<Integer> nullLines = new ArrayList<Integer>();
//			for(int j = 0;j<oneLevel.get(0).size();j++) {
//				nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
//			}
//			nullScreen.add(nullLines);
//		}
//		oneLevel.addAll(0, nullScreen);
////		int x0 = 0;
////		for(int y = (int) 0;y<MEGA_MAN_LEVEL_HEIGHT;y++) {
////			for(int x = (int) previousMove.getX();x<previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x++) {
////				oneLevel.get(y).set(x, levelInListUp.get(level).get(y).get(x0));
////				x0++;
////			}
////			x0=0;
////		}
//		}
//		//now at the previous point, add in a new version of levelInList.get(level)
//		List<List<Integer>> placingScreen = new ArrayList<List<Integer>>();
//		
//		for(int i = 0;i<levelInListUp.get(level).size();i++) {
//			List<Integer> placeLine = new ArrayList<>();
//
//			for(int j = 0;j<levelInListUp.get(level).get(0).size();j++) {
//				if(levelInListUp.get(level).get(i).get(j)!=9)
//				placeLine.add(levelInListUp.get(level).get(i).get(j));
//			}
//			if(!placeLine.isEmpty())
//			placingScreen.add(placeLine);
//			
//		}
//
//		
//		for(int y = (int) previousMove.getY();y<previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y++) {
//			for(int x = (int) previousMove.getX();x<previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x++) {
//
//				oneLevel.get(y).set(x, placingScreen.get((int) (y - (int)previousMove.getY())).get((int) (x-(int)previousMove.getX())));
//			}
//
//		}
//		
//		
//	}
//
//	public static void placeRight(List<List<List<Integer>>> levelInListHorizontal, Point previousMove,
//			List<List<Integer>> oneLevel, List<Integer> nullLine, int level) {
//		for(int i = 0;i<oneLevel.size();i++) { //add null to all spaces to the right TODO possibly change
//			oneLevel.get(i).addAll(nullLine);
//		}
//		//MegaManVGLCUtil.printLevel(oneLevel);
//		//take the information from the previous run to replace null with a level in the appropriate spots
//		for(int x = (int) previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x<(int) previousMove.getX()+2*MEGA_MAN_LEVEL_WIDTH;x++) {
//			for(int y = (int) previousMove.getY();y<(int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y++) {
////						System.out.println(x+", "+y);
////						System.out.println(previousMove.getX()+", "+previousMove.getY());
//				//System.out.println(x+", "+y);
//				oneLevel.get(y).set(x, levelInListHorizontal.get(level).get((int) (y - previousMove.getY())).get((int) (x-MEGA_MAN_LEVEL_WIDTH-previousMove.getX())));
//			}
//		}
//	}

	
	
	public static void placeSpawn(List<List<Integer>> level) {
		boolean placed = false;
		for(int x = 0;x<level.get(0).size();x++) {
			for(int y = 0;y<level.size();y++) {
				if(y-2>=0&&(level.get(y).get(x)==1||level.get(y).get(x)==2)&&(level.get(y-1).get(x)==0||level.get(y-1).get(x)==10)&&(level.get(y-2).get(x)==0||level.get(y-1).get(x)==10)) {
					level.get(y-1).set(x, 8);
					placed = true;
					break;
				}
			}
			if(placed) {
				break;
			}
			
		
		}
		for(int i = 0; i<level.get(0).size();i++) {
			if(!placed) {
				level.get(level.size()-1).set(0, 1);
				level.get(level.size()-2).set(0, 8);
				level.get(level.size()-3).set(0, 0);
				placed = true;
			}
		}

	}
	public static void placeOrb(List<List<Integer>> level) {
		boolean placed = false;
		
			for(int x = level.get(0).size()-1;x>=0; x--) {
				for(int y = level.size()-1; y>=0;y--) {
					//System.out.println(x+", "+y);
				if(y-2>=0&&(level.get(y).get(x)==2||level.get(y).get(x)==1||level.get(y).get(x)==5)&&(level.get(y-1).get(x)==0||level.get(y-1).get(x)==10)) {
					level.get(y-1).set(x, 7);
					level.get(y-2).set(x,  MegaManVGLCUtil.ONE_ENEMY_AIR);
					placed=true;
					break;
					
				}
			}
			if(placed) break;
		}
			for(int i = 0; i<level.get(0).size();i++) {
				if(!placed) {
					level.get(level.size()-1).set(0, MegaManVGLCUtil.ONE_ENEMY_SOLID);
					level.get(level.size()-2).set(0, MegaManVGLCUtil.ONE_ENEMY_ORB);
					level.get(level.size()-3).set(0, MegaManVGLCUtil.ONE_ENEMY_AIR);
					placed = true;
				}
			}
	}
	
	public static HashMap<String, Integer> findMiscSegments(List<List<Integer>> level){
		HashMap<String, Integer> j = new HashMap<>();
		j.put("numUp", numUp);
		j.put("numDown", numDown);
		j.put("numRight", numRight);
		j.put("numLeft", numLeft);
		j.put("numCorner", numCorner);
		j.put("numDistinctSegments", numDistinctSegments);
		return j;
	}
	
	
	

//	public static void placeDownCPPN(List<List<List<Integer>>> levelInListDown, Point previousMove,
//			List<List<Integer>> oneLevel, int level) {
//			List<List<Integer>> nullScreen = new ArrayList<List<Integer>>();
//			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
//				List<Integer> nullLines = new ArrayList<Integer>();
//				for(int j = 0;j<oneLevel.get(0).size();j++) {
//					nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
//				}
//				nullScreen.add(nullLines);
//			}
//			oneLevel.addAll(oneLevel.size(), nullScreen);
//
//		for(int y = (int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y<previousMove.getY()+2*MEGA_MAN_LEVEL_HEIGHT;y++) {
//			for(int x = (int) previousMove.getX();x<previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x++) {
//				oneLevel.get(y).set(x, levelInListDown.get(level).get((int) (y -MEGA_MAN_LEVEL_HEIGHT- previousMove.getY())).get((int) (x-previousMove.getX())));
//			}
//		}
//	}
//
//	public static void placeUpCPPN(List<List<List<Integer>>> levelInListUp, Point previousMove,
//			List<List<Integer>> oneLevel, int level) {
//
//		List<List<Integer>> nullScreen = new ArrayList<List<Integer>>();
//		for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
//			List<Integer> nullLines = new ArrayList<Integer>();
//			for(int j = 0;j<oneLevel.get(0).size();j++) {
//				nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
//			}
//			nullScreen.add(nullLines);
//		}
//		oneLevel.addAll(0, nullScreen);
//		
//		//now at the previous point, add in a new version of levelInList.get(level)
//		List<List<Integer>> placingScreen = new ArrayList<List<Integer>>();
//		
//		for(int i = 0;i<levelInListUp.get(level).size();i++) {
//			List<Integer> placeLine = new ArrayList<>();
//
//			for(int j = 0;j<levelInListUp.get(level).get(0).size();j++) {
//				if(levelInListUp.get(level).get(i).get(j)!=MegaManVGLCUtil.ONE_ENEMY_NULL)
//				placeLine.add(levelInListUp.get(level).get(i).get(j));
//			}
//			if(!placeLine.isEmpty())
//			placingScreen.add(placeLine);
//			
//		}
//
//		
//		for(int y = (int) previousMove.getY();y<previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y++) {
//			for(int x = (int) previousMove.getX();x<previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x++) {
//
//				oneLevel.get(y).set(x, placingScreen.get((int) (y - (int)previousMove.getY())).get((int) (x-(int)previousMove.getX())));
//			}
//
//		}
//		
//		
//	}
//
//	public static void placeRightCPPN(List<List<List<Integer>>> levelInListHorizontal, Point previousMove,
//			List<List<Integer>> oneLevel, List<Integer> nullLine, int level) {
//		for(int i = 0;i<oneLevel.size();i++) { //add null to all spaces to the right TODO possibly change
//			oneLevel.get(i).addAll(nullLine);
//		}
//		for(int x = (int) previousMove.getX()+MEGA_MAN_LEVEL_WIDTH;x<(int) previousMove.getX()+2*MEGA_MAN_LEVEL_WIDTH;x++) {
//			for(int y = (int) previousMove.getY();y<(int) previousMove.getY()+MEGA_MAN_LEVEL_HEIGHT;y++) {
//				oneLevel.get(y).set(x, levelInListHorizontal.get(level).get((int) (y - previousMove.getY())).get((int) (x-MEGA_MAN_LEVEL_WIDTH-previousMove.getX())));
//			}
//		}
//	}
	
	
	
	/**
	 * 
	 * @param width how many segments
	 * @param segmentLength - the length of one segment
	 * @param wholeVector - the entire vector from realvaluedgenotype
	 * @return portion of vector corresponding to one segment
	 */
	public static double[] latentVectorAndMiscDataForPosition(int width,int segmentLength, double[] wholeVector) { 
		int startIndex = segmentLength*(width);
		double[] result = new double[segmentLength]; //resets size of result to be the same length
		System.arraycopy(wholeVector, startIndex, result, 0, segmentLength);
		return result;
	}
	
	
	
	
	
	
	
	
	
	
//	
//	public static HashSet<List<List<Integer>>> distinct;
//	public static int x = 0;
//	public static int y = 0;
//	public static Point previousMove;
	
//	public static Direction d;
	
	public static List<List<Integer>> longVectorToMegaManLevel(MegaManGANGenerator megaManGANGenerator, double[] wholeVector, int chunks, MegaManTrackSegmentType segmentCount){
		
		HashSet<Point> previousPoints = new HashSet<>();
		Point currentPoint  = new Point(0,0);
		Point previousPoint = null;
		Point placementPoint = currentPoint;
		List<List<Integer>> level = new ArrayList<>();
		List<List<Integer>> segment = new ArrayList<>();
		HashSet<List<List<Integer>>> distinct = new HashSet<>();
		for(int i = 0;i<chunks;i++) {
			double[] oneSegmentData = latentVectorAndMiscDataForPosition(i, Parameters.parameters.integerParameter("GANInputSize")+MegaManGANGenerator.numberOfAuxiliaryVariables(), wholeVector);
			Pair<List<List<Integer>>, Point> segmentAndPoint = megaManGANGenerator.generateSegmentFromVariables(oneSegmentData, previousPoint, previousPoints, currentPoint);
			if(segmentAndPoint==null) {
				break; //NEEDS TO BE FIXED!! ORB WILL NOT BE PLACED
			}
			segment = segmentAndPoint.t1;
			segmentCount.findSegmentData(megaManGANGenerator.getSegmentType(), segment, distinct);

			previousPoint = currentPoint; // backup previous
			currentPoint = segmentAndPoint.t2;
			if(i==chunks-1) placeOrb(segment);
			
			placementPoint = placeMegaManSegment(level, segment,  currentPoint, previousPoint, placementPoint);

		}
		
		postProcessingPlaceProperEnemies(level);
		return level;
		
	}

	public static Point placeMegaManSegment(List<List<Integer>> level,List<List<Integer>> segment, Point current, Point prev, Point placementPoint) {
		if(level.isEmpty()) { // First segment
			//System.out.println("FIRST");
			for(List<Integer> row : segment) {
				ArrayList<Integer> newRow = new ArrayList<>(row.size());
				newRow.addAll(row);
				level.add(newRow);
			}
		
//			System.out.println("Placing Spawn");
			placeSpawn(level);
//			MegaManVGLCUtil.printLevel(level);
//			MiscUtil.waitForReadStringAndEnterKeyPress();
			
			
			// Schrum:  I'm  really not sure what belongs here, of it this deserves its own case
			
			//placementPoint = new Point(current.x, current.y);
			placementPoint = findInitialPlacementPoint(prev, current, placementPoint);
		} else if(current.equals(new Point(prev.x+1, prev.y))) {
			//System.out.println("RIGHT");
			placeRightSegment(level, segment, placementPoint);
			placementPoint = new Point(placementPoint.x+MEGA_MAN_LEVEL_WIDTH, placementPoint.y);
		} else if(current.equals(new Point(prev.x, prev.y+1))) {
			//System.out.println("DOWN");
			placeDownSegment(level, segment, placementPoint);
			placementPoint = new Point(placementPoint.x, placementPoint.y+MEGA_MAN_LEVEL_HEIGHT);
		} else if(current.equals(new Point(prev.x, prev.y-1))) {
			//System.out.println("UP");
			placeUpSegment(level, segment, placementPoint);
			placementPoint = new Point(placementPoint.x, placementPoint.y-MEGA_MAN_LEVEL_HEIGHT);
		} else if(current.equals(new Point(prev.x-1, prev.y))) {
//			System.out.println("LEFT");
			placeLeftSegment(level, segment, placementPoint);
			placementPoint = new Point(placementPoint.x-MEGA_MAN_LEVEL_WIDTH, placementPoint.y);
		}
		return placementPoint;
	}

	
	private static Point findInitialPlacementPoint(Point prev, Point current, Point placementPoint) {
		prev = new Point(0,0);
		if(current.equals(new Point(prev.x+1, prev.y))) {
			placementPoint = new Point(placementPoint.x+MEGA_MAN_LEVEL_WIDTH, placementPoint.y);
		} else if(current.equals(new Point(prev.x, prev.y+1))) {
			placementPoint = new Point(placementPoint.x, placementPoint.y+MEGA_MAN_LEVEL_HEIGHT);
		} else if(current.equals(new Point(prev.x, prev.y-1))) {
			placementPoint = new Point(placementPoint.x, placementPoint.y-MEGA_MAN_LEVEL_HEIGHT);
		} else if(current.equals(new Point(prev.x-1, prev.y))) {
			placementPoint = new Point(placementPoint.x-MEGA_MAN_LEVEL_WIDTH, placementPoint.y);
		}
		return placementPoint;
	}
	
	
	private static void placeLeftSegment(List<List<Integer>> level, List<List<Integer>> segment, Point placementPoint) {
		// TODO Auto-generated method stub
		if(placementPoint.x<0) { //add null lines to left
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(0,nullLine);
				
			}
			
			placementPoint.x += MEGA_MAN_LEVEL_WIDTH;
		}
		if(placementPoint.x+MEGA_MAN_LEVEL_WIDTH>level.get(0).size()) {
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
			for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
				level.get(i).addAll(nullLine);
			}
			
		
		}
		if(placementPoint.y>=level.size()) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
				}
				
				nullScreen.add(nullLines);
			}
			if(level.size()==0) {
				
			}
			level.addAll(level.size(), nullScreen);
		}
		
		if(placementPoint.y<0) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					
				}
				nullScreen.add(nullLines);
			}
			level.addAll(0, nullScreen);
			placementPoint.y+=MEGA_MAN_LEVEL_HEIGHT;
		}
		
		for(int x = placementPoint.x; x < placementPoint.x+MEGA_MAN_LEVEL_WIDTH;x++) {
			for(int y = placementPoint.y;y<placementPoint.y+MEGA_MAN_LEVEL_HEIGHT;y++) {
				level.get(y).set(x, segment.get(y-placementPoint.y).get(x - placementPoint.x));
			}
		}
//		MegaManVGLCUtil.printLevel(level);
//		MiscUtil.waitForReadStringAndEnterKeyPress();
		
	}

	private static void placeRightSegment(List<List<Integer>> level, List<List<Integer>> segment, Point placementPoint) {
		// TODO Auto-generated method stub
		if(placementPoint.x+MEGA_MAN_LEVEL_WIDTH>level.get(0).size()) {
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(nullLine);
				}
		}
		
		if(placementPoint.x<0) { //add null lines to left
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(0,nullLine);
				
			}
			
			placementPoint.x += MEGA_MAN_LEVEL_WIDTH;
		}
		if(placementPoint.y>=level.size()) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
				
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					}
				
				nullScreen.add(nullLines);
			}
			if(level.size()==0) {
				
			}
			level.addAll(level.size(), nullScreen);
		}
		
		if(placementPoint.y<0) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
				}
				nullScreen.add(nullLines);
			}
			level.addAll(0, nullScreen);
			placementPoint.y+=MEGA_MAN_LEVEL_HEIGHT;
		}
		for(int x = placementPoint.x; x < placementPoint.x+MEGA_MAN_LEVEL_WIDTH;x++) {
			for(int y = placementPoint.y;y<placementPoint.y+MEGA_MAN_LEVEL_HEIGHT;y++) {
				level.get(y).set(x, segment.get(y-placementPoint.y).get(x - placementPoint.x));
			}
		}

		
	}

	private static void placeUpSegment(List<List<Integer>> level, List<List<Integer>> segment, Point placementPoint) {
		// TODO Auto-generated method stub
		if(placementPoint.y<0) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					}
				
				nullScreen.add(nullLines);
			}
			level.addAll(0, nullScreen);
			placementPoint.y+=MEGA_MAN_LEVEL_HEIGHT;
		}
		if(placementPoint.x<0) { //add null lines to left
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(0,nullLine);
			}
			
			placementPoint.x += MEGA_MAN_LEVEL_WIDTH;
		}
		
		if(placementPoint.x>=level.get(0).size()) {
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}

				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(nullLine);
				}
			
			
		
		}
		if(placementPoint.y+MEGA_MAN_LEVEL_HEIGHT>level.size()) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
				
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					}

				
				nullScreen.add(nullLines);
			}
			if(level.size()==0) {
				
			}
			level.addAll(level.size(), nullScreen);
		}
		for(int x = placementPoint.x; x < placementPoint.x+MEGA_MAN_LEVEL_WIDTH;x++) {
			for(int y = placementPoint.y;y<placementPoint.y+MEGA_MAN_LEVEL_HEIGHT;y++) {
				level.get(y).set(x, segment.get(y-placementPoint.y).get(x - placementPoint.x));
			}
		}
		
		
	}

	private static void placeDownSegment(List<List<Integer>> level, List<List<Integer>> segment, Point placementPoint) {
		if(placementPoint.y+MEGA_MAN_LEVEL_HEIGHT>level.size()) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();

					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					}
				
				
				nullScreen.add(nullLines);
			}
			if(level.size()==0) {
				
			}
			level.addAll(level.size(), nullScreen);
		}
		if(placementPoint.x<0) { //add null lines to left
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
		
				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(0,nullLine);
				
			}
			
			placementPoint.x += MEGA_MAN_LEVEL_WIDTH;
		}
		if(placementPoint.x>=level.get(0).size()) {
			List<Integer> nullLine = new ArrayList<>();
			for(int i = 0;i<segment.get(0).size();i++) {
				nullLine.add(MegaManVGLCUtil.ONE_ENEMY_NULL);
			}
			
//				System.out.println(level.size());
//				System.out.println(nullLine.toString());

				for(int i = 0;i<level.size();i++) { //add null to all spaces to the right TODO possibly change
					level.get(i).addAll(nullLine);
				}
			
		
		
		}
		if(placementPoint.y<0) {
			List<List<Integer>> nullScreen = new ArrayList<>();
			for(int i = 0;i<MEGA_MAN_LEVEL_HEIGHT;i++) {
				List<Integer> nullLines = new ArrayList<Integer>();
			
					for(int j = 0;j<level.get(0).size();j++) {
						nullLines.add(MegaManState.MEGA_MAN_TILE_NULL);
					}
				
				nullScreen.add(nullLines);
			}
			level.addAll(0, nullScreen);
			placementPoint.y+=MEGA_MAN_LEVEL_HEIGHT;
		}
		
		for(int x = placementPoint.x; x < placementPoint.x+MEGA_MAN_LEVEL_WIDTH;x++) {
			for(int y = placementPoint.y; y < placementPoint.y+MEGA_MAN_LEVEL_HEIGHT;y++) {
//				System.out.println(x+", "+y);
//				MegaManVGLCUtil.printLevel(level);
				level.get(y).set(x, segment.get(y-placementPoint.y).get(x - placementPoint.x));
			}
		}
		
	}

//	public static List<List<Integer>> wholeVectorToMegaManLevel(GANProcess ganProcessHorizontal,
//			GANProcess ganProcessDown, GANProcess ganProcessUp, GANProcess lowerLeftGAN, 
//			GANProcess lowerRightGAN,  GANProcess upperLeftGAN, GANProcess upperRightGAN, int chunks, double[] wholeVector){
//		HashSet<Point> placedPoints = new HashSet<>();
//		Direction previousDirection = null;
//		List<List<Integer>> level = new ArrayList<>();
//		Point currentPoint = new Point();
//		for(int i = 0;i<chunks;i++) {
//			placeSegmentWithAppropriateGAN(currentPoint, level,placedPoints,wholeVector, i, previousDirection, ganProcessHorizontal,ganProcessUp,ganProcessDown,lowerLeftGAN,lowerRightGAN,upperLeftGAN,upperRightGAN);
//		}
//		
//		
//		
//		return level;
//	}
//	
//	// These variables also inappropriate
//	public final static int NUM_AUX = 3;
//	public final static int NUM_LATENT = 5;
//	public final static int TOTAL_VARIABLES = 8;
///**
// * Takes in all GANs and the entire vector representing the auxillary values and then the latent inputs
// * 
// * @param wholeVector
// * @param segmentNum
// * @param previousDirection
// * @param ganProcessHorizontal
// * @param ganProcessUp
// * @param ganProcessDown
// * @param lowerLeftGAN
// * @param lowerRightGAN
// * @param upperLeftGAN
// * @param upperRightGAN
// * @return
// */
//private static void placeSegmentWithAppropriateGAN(Point currentPoint, List<List<Integer>> level, HashSet<Point> placedPoints, double[] wholeVector, int segmentNum, Direction previousDirection,
//		GANProcess ganProcessHorizontal, GANProcess ganProcessUp, GANProcess ganProcessDown, GANProcess lowerLeftGAN,
//		GANProcess lowerRightGAN, GANProcess upperLeftGAN, GANProcess upperRightGAN) {
//	// TODO Auto-generated method stub
////	System.out.println(segmentNum+", "+wholeVector.length);
//	double[] oneSegmentData = latentVectorAndMiscDataForPosition(segmentNum, Parameters.parameters.integerParameter("GANInputSize"), wholeVector);
//	Direction current = useLongVectorToFindDirection(currentPoint, placedPoints,oneSegmentData, segmentNum, previousDirection);
//	if(previousDirection==null) {
//		placeFirstSegment(oneSegmentData, level, current, segmentNum, ganProcessHorizontal,ganProcessUp,ganProcessDown);
//		currentPoint = new Point(0,0);
//		placedPoints.add(currentPoint);
//	}
//	else if(previousDirection.equals(current)) {
//		placeNoCorners(oneSegmentData, current, currentPoint, level, ganProcessHorizontal,ganProcessUp,ganProcessDown, placedPoints);
//	}
//	else {
//		placeCornerSegments(previousDirection, oneSegmentData, current, currentPoint, level,lowerLeftGAN,lowerRightGAN,upperLeftGAN,upperRightGAN, placedPoints);
//	}
//}
///**
// * places the corner segments
// * @param oneSegmentData
// * @param current
// * @param currentPoint
// * @param level
// * @param lowerLeftGAN
// * @param lowerRightGAN
// * @param upperLeftGAN
// * @param upperRightGAN
// */
//private static void placeCornerSegments(Direction previous, double[] oneSegmentData, Direction current, Point currentPoint,
//		List<List<Integer>> level, GANProcess lowerLeftGAN, GANProcess lowerRightGAN, GANProcess upperLeftGAN,
//		GANProcess upperRightGAN, HashSet<Point> placedPoints) {
//	List<Integer> nullLine = new ArrayList<Integer>(16);
//	for(int i=0;i<MegaManGANUtil.MEGA_MAN_LEVEL_WIDTH;i++) {
//		nullLine.add(MegaManState.MEGA_MAN_TILE_NULL);
//	}
//	double[] latentVector = new double[oneSegmentData.length-NUM_AUX];
//	for(int i = NUM_AUX;i<TOTAL_VARIABLES;i++) {
//		latentVector[i-NUM_AUX]=oneSegmentData[i];
//	}
//	
//	
//	
//	if(previous.equals(Direction.UP)&&current.equals(Direction.RIGHT)) {//place upper left
//		placeUpCPPN(getLevelListRepresentationFromGAN(upperLeftGAN, latentVector), currentPoint, level, 0);
//		y++;
//		numUp++;
//	}
//	else if(previous.equals(Direction.DOWN)&&current.equals(Direction.RIGHT)) { //place lower left
//		y--;
//		numDown++;
//		placeDownCPPN(getLevelListRepresentationFromGAN(lowerLeftGAN, latentVector), currentPoint, level, 0);
//		currentPoint=new Point((int) currentPoint.getX(),(int) currentPoint.getY()+MEGA_MAN_LEVEL_HEIGHT);
//	}
//	else if(previous.equals(Direction.RIGHT)&&current.equals(Direction.UP)) { //place lower right
//		MegaManGANUtil.placeRightCPPN(MegaManGANUtil.getLevelListRepresentationFromGAN(lowerRightGAN, latentVector), currentPoint, level, nullLine, 0);
//		x++;
//		distinct.add(MegaManGANUtil.getLevelListRepresentationFromGAN(lowerRightGAN, latentVector).get(0));
//		currentPoint=new Point((int) currentPoint.getX()+MEGA_MAN_LEVEL_WIDTH,(int) currentPoint.getY());
//
//	}
//	else if(previous.equals(Direction.RIGHT)&&current.equals(Direction.DOWN)) { //place upper right
//		MegaManGANUtil.placeRightCPPN(MegaManGANUtil.getLevelListRepresentationFromGAN(upperRightGAN, latentVector), currentPoint, level, nullLine, 0);
//		x++;
//		distinct.add(MegaManGANUtil.getLevelListRepresentationFromGAN(upperRightGAN, latentVector).get(0));
//		currentPoint=new Point((int) currentPoint.getX()+MEGA_MAN_LEVEL_WIDTH,(int) currentPoint.getY());
//	}
//	placedPoints.add(currentPoint);
//	
//}
//
///**
// * Places a segment without a corner
// * @param current
// * @param currentPoint
// */
//private static void placeNoCorners(double[] oneSegmentData, Direction current, Point currentPoint, List<List<Integer>> level, GANProcess ganProcessHorizontal, GANProcess ganProcessUp,
//		GANProcess ganProcessDown, HashSet<Point> placedPoints) {
//	List<Integer> nullLine = new ArrayList<Integer>(16);
//	for(int i=0;i<MEGA_MAN_LEVEL_WIDTH;i++) {
//		nullLine.add(MegaManState.MEGA_MAN_TILE_NULL);
//	}
//	double[] startlatentVector = new double[oneSegmentData.length-NUM_AUX];
//	for(int i = NUM_AUX;i<TOTAL_VARIABLES;i++) {
//		startlatentVector[i-NUM_AUX]=oneSegmentData[i];
//	}
//	if(current.equals(Direction.RIGHT)) {
//		numHorizontal++;
//		x++;
//		placeRightCPPN(getLevelListRepresentationFromGAN(ganProcessHorizontal, startlatentVector), currentPoint, level, nullLine, 0);
//		currentPoint=new Point((int) currentPoint.getX()+MEGA_MAN_LEVEL_WIDTH,(int) currentPoint.getY());
//		
//	}else if(current.equals(Direction.UP)) {
//		placeUpCPPN(getLevelListRepresentationFromGAN(ganProcessUp, startlatentVector), currentPoint, level, 0);
//		y++;
//		numUp++;
//	}else if(current.equals(Direction.DOWN)) {
//		y--;
//		numDown++;
//		placeDownCPPN(getLevelListRepresentationFromGAN(ganProcessDown, startlatentVector), currentPoint, level, 0);
//		currentPoint=new Point((int) currentPoint.getX(),(int) currentPoint.getY()+MEGA_MAN_LEVEL_HEIGHT);
//	}
//	placedPoints.add(currentPoint);
//}
//
///**
// * places the first segment in the data set.
// * @param oneSegmentData
// * @param oneLevel
// * @param current
// * @param segmentNum
// * @param ganProcessHorizontal
// * @param ganProcessUp
// * @param ganProcessDown
// * @param lowerLeftGAN
// * @param lowerRightGAN
// * @param upperLeftGAN
// * @param upperRightGAN
// */
//private static void placeFirstSegment(double[] oneSegmentData, List<List<Integer>> oneLevel,Direction current,int segmentNum, GANProcess ganProcessHorizontal, GANProcess ganProcessUp,
//		GANProcess ganProcessDown) {
//	double[] startlatentVector = new double[oneSegmentData.length-NUM_AUX];
//	for(int i = NUM_AUX;i<TOTAL_VARIABLES;i++) {
//		startlatentVector[i-NUM_AUX]=oneSegmentData[i];
//	}
//	if(current.equals(Direction.UP)) {
//		numUp++;
//		oneLevel = getLevelListRepresentationFromGAN(ganProcessUp, startlatentVector).get(0);
//	}
//	else if (current.equals(Direction.DOWN)) {
//		numDown++;
//		oneLevel = getLevelListRepresentationFromGAN(ganProcessDown, startlatentVector).get(0);
//	}
//	else if(current.equals(Direction.RIGHT)) {
//		numHorizontal++;
//		
//		oneLevel = getLevelListRepresentationFromGAN(ganProcessHorizontal, startlatentVector).get(0);
//	}
//
//	
//}
//
///**
// * Uses the long vector to determine which direction to place
// * If placing the first segment, simply use the highest preference
// * Otherwise, determine which appropriate backup to use.
// * @param wholeVector
// * @param segmentNum
// * @param previous
// * @return
// */
//private static Direction useLongVectorToFindDirection(Point currentPoint, HashSet<Point> placedPoints, double[] oneSegmentData, int segmentNum, Direction previous) {
//	// TODO Auto-generated method stub
//	if(previous==null) return findFirstDirection(oneSegmentData, segmentNum);
//	else {
//		double[] outputs = new double[NUM_AUX];
//		for(int i =0;i<NUM_AUX;i++) {
//			outputs[i]=oneSegmentData[i];
//		}
//		int direction = StatisticsUtilities.argmax(outputs);
//		double[] backup = new double[NUM_AUX];
//		for(int i = 0;i<NUM_AUX;i++) {
//			if(i!=direction) {
//				backup[i]=outputs[i];
//			}
//		}
//		int bkp = StatisticsUtilities.argmax(backup);
//		double[] backup1 = new double[NUM_AUX];
//		for(int i = 0;i<NUM_AUX;i++) {
//			if(i!=direction&&i!=bkp) {
//				backup1[i]=outputs[i];
//			}
//		}
//		int bkp1 = StatisticsUtilities.argmax(backup1);
//		boolean needBackup = true;
//		int x = (int) currentPoint.getX();
//		int y = (int) currentPoint.getY();
//		Direction current=null;
//		needBackup = useBackupOrSetCurrentDirection(current, placedPoints, direction, x, y);
//		if(needBackup) needBackup = useBackupOrSetCurrentDirection(current, placedPoints, bkp, x, y);
//		if(needBackup) needBackup = useBackupOrSetCurrentDirection(current, placedPoints, bkp1, x, y);
//		return current;
//	}
//}
//
///**
// * finds the direction needed when taking into account corner cases.
// * @param placedPoints
// * @param oneSegmentData
// * @param segmentNum
// * @return
// */
//private static boolean useBackupOrSetCurrentDirection(Direction current, HashSet<Point> placedPoints, int direction, int x, int y) {
//	boolean needBackup = true;
//	
//	if(direction == MegaManCPPNtoGANLevelBreederTask.UP_PREFERENCE&&!placedPoints.contains(new Point(x, y))) {
//		current = Direction.UP;
//		needBackup=false;
//	}
//	else if (direction == MegaManCPPNtoGANLevelBreederTask.DOWN_PREFERENCE&&!placedPoints.contains(new Point(x, y+MEGA_MAN_LEVEL_HEIGHT))) { //level height
//		current = Direction.DOWN;
//		needBackup=false;
//	}
//	else if(direction==MegaManCPPNtoGANLevelBreederTask.HORIZONTAL_PREFERENCE&&!placedPoints.contains(new Point(x+MEGA_MAN_LEVEL_WIDTH, y))){ //level width
//		current=Direction.RIGHT;
//		needBackup=false;
//	}
//	return needBackup;
//}
//
///**
// * Finds the initial direction to go in.
// * @param wholeVector
// * @param segmentNum
// * @return
// */
//private static Direction findFirstDirection(double[] oneSegmentData, int segmentNum) {
//	double[] startlatentVector = new double[oneSegmentData.length-NUM_AUX];
//	for(int i = NUM_AUX;i<TOTAL_VARIABLES;i++) {
//		startlatentVector[i-NUM_AUX]=oneSegmentData[i];
//	}
//	double[] startoutput = new double[3];
//	for(int i =0;i<NUM_AUX;i++) {
//		startoutput[i]=oneSegmentData[i];
//	}
//	
//	int startdirection = StatisticsUtilities.argmax(startoutput);
//	Direction startDirection = null;
//	if(startdirection == MegaManCPPNtoGANLevelBreederTask.UP_PREFERENCE) {
//		startDirection = Direction.UP;
//	}
//	else if (startdirection == MegaManCPPNtoGANLevelBreederTask.DOWN_PREFERENCE) {
//		startDirection = Direction.DOWN;
//
//	}
//	else if(startdirection == MegaManCPPNtoGANLevelBreederTask.HORIZONTAL_PREFERENCE) {
//		startDirection = Direction.RIGHT;
//
//	}
//	return startDirection;
//}
//	
//	public static List<List<Integer>> wholeVectorToMegaManLevel(GANProcess ganProcessHorizontal,
//			GANProcess ganProcessDown, GANProcess ganProcessUp, GANProcess lowerLeftGAN, 
//			GANProcess lowerRightGAN,  GANProcess upperLeftGAN, GANProcess upperRightGAN, int chunks, double[] wholeVector){
//		 numHorizontal = 0;
//		 numUp = 0;
//		 numDown = 0;
//		 numCorner = 0;
//		 numDistinctSegments = 0;
//		 distinct = new HashSet<>();
//		 x = 0;
//		 y = 0;
////		for(double k :inputMultipliers) {
////			System.out.println(k);
////		}
//		
//
//		List<List<Integer>> oneLevel;
////		levelInListHorizontal = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessHorizontal, latentVector);
////		levelInListUp = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessUp, latentVector);
////		levelInListDown = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessDown, latentVector);
//		d = null;
//		//System.out.println(MegaManCPPNtoGANLevelBreederTask.staticNumCPPNOutputs());
//		double[] startfull = latentVectorAndMiscDataForPosition(0,8,wholeVector);
//		//System.out.println(startfull.length);
//
//		double[] startlatentVector = new double[startfull.length-3];
//		for(int i = 3;i<startfull.length;i++) {
//			startlatentVector[i-3]=startfull[i];
//		}
//		
//		List<List<List<Integer>>> levelInListHorizontal = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessHorizontal, startlatentVector);
//		List<List<List<Integer>>> levelInListUp = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessUp, startlatentVector);
//		List<List<List<Integer>>> levelInListDown = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessDown, startlatentVector);
//		List<List<List<Integer>>> levelInListUpperRight; /*= getLevelListRepresentationFromGAN(upperRightGAN, latentVector);*/
//		List<List<List<Integer>>> levelInListUpperLeft;/*= getLevelListRepresentationFromGAN(upperLeftGAN, latentVector);*/
//		List<List<List<Integer>>> levelInListLowerRight; /*= getLevelListRepresentationFromGAN(lowerRightGAN, latentVector);*/
//		List<List<List<Integer>>> levelInListLowerLeft; /*= getLevelListRepresentationFromGAN(lowerLeftGAN, latentVector);*/
//		
//		double[] startoutput = new double[3];
//		for(int i =0;i<3;i++) {
//			startoutput[i]=startfull[i];
//		}
//		
//		int startdirection = StatisticsUtilities.argmax(startoutput);
//		oneLevel = MegaManCPPNtoGANUtil.placeInitialDirection(ganProcessHorizontal, startlatentVector, levelInListUp, levelInListDown,
//				startdirection);
//		distinct.add(oneLevel);
//		MegaManGANUtil.placeSpawn(oneLevel);
//		if(chunks==1) {
//			MegaManGANUtil.placeOrb(oneLevel);
//		}
//		List<Integer> nullLine = new ArrayList<Integer>(16);
//		for(int i=0;i<MegaManGANUtil.MEGA_MAN_LEVEL_WIDTH;i++) {
//			nullLine.add(MegaManState.MEGA_MAN_TILE_NULL);
//		}
//		previousMove = new Point(0,0);
//		for(int segment = 1; segment < chunks; segment++) {
//			MegaManCPPNtoGANUtil.Direction previous = d;
//			double[] full =  latentVectorAndMiscDataForPosition(segment,8,wholeVector);
//			double[] latentVector = new double[full.length-3];
//			for(int i = 3;i<full.length;i++) {
//				latentVector[i-3]=full[i];
//			}
//			double[] outputs = new double[3];
//			for(int i =0;i<3;i++) {
//				outputs[i]=full[i];
//			}
//			int direction = StatisticsUtilities.argmax(outputs);
//			double[] backup = new double[3];
//			for(int i = 0;i<3;i++) {
//				if(i!=direction) {
//					backup[i]=outputs[i];
//				}
//			}
//			int bkp = StatisticsUtilities.argmax(backup);
//			double[] backup1 = new double[3];
//			for(int i = 0;i<3;i++) {
//				if(i!=direction&&i!=bkp) {
//					backup1[i]=outputs[i];
//				}
//			}
//			int bkp1 = StatisticsUtilities.argmax(backup1);
//			boolean needBackup = true;
//			levelInListLowerRight = MegaManGANUtil.getLevelListRepresentationFromGAN(lowerRightGAN, latentVector);
//			levelInListUp = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessUp, latentVector);
//			levelInListUpperRight = MegaManGANUtil.getLevelListRepresentationFromGAN(upperRightGAN, latentVector);
//			levelInListDown = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessDown, latentVector);
//			levelInListHorizontal = MegaManGANUtil.getLevelListRepresentationFromGAN(ganProcessHorizontal, latentVector);
//			levelInListUpperLeft = MegaManGANUtil.getLevelListRepresentationFromGAN(upperLeftGAN, latentVector);
//			levelInListLowerLeft = MegaManGANUtil.getLevelListRepresentationFromGAN(lowerLeftGAN, latentVector);
//			
//			needBackup = MegaManCPPNtoGANUtil.addLevelSegment(chunks, oneLevel, levelInListHorizontal, levelInListUp, levelInListDown,
//					levelInListUpperRight, levelInListUpperLeft, levelInListLowerRight, levelInListLowerLeft, nullLine,
//					segment, previous, direction, needBackup);
//			
//			
//			if(needBackup) {
//				needBackup = MegaManCPPNtoGANUtil.addLevelSegment(chunks, oneLevel, levelInListHorizontal, levelInListUp, levelInListDown,
//						levelInListUpperRight, levelInListUpperLeft, levelInListLowerRight, levelInListLowerLeft, nullLine,
//						segment, previous, bkp, needBackup);
//				
//			}
//			if(needBackup) {
//				needBackup = MegaManCPPNtoGANUtil.addLevelSegment(chunks, oneLevel, levelInListHorizontal, levelInListUp, levelInListDown,
//						levelInListUpperRight, levelInListUpperLeft, levelInListLowerRight, levelInListLowerLeft, nullLine,
//						segment, previous, bkp1, needBackup);
//				
//			}
//			if(!d.equals(previous)) {
//				numCorner++;
//			}
//			previous = d;
//			numDistinctSegments = distinct.size();
//		}
//		
//		
////		ganProcessUp.terminate();
////		ganProcessDown.terminate();
////		ganProcessHorizontal.terminate();
//		if(!Parameters.parameters.booleanParameter("megaManUsesUniqueEnemies")) {
//			MegaManGANUtil.postProcessingPlaceProperEnemies(oneLevel);
//		}
//		return oneLevel;
//	}
}
